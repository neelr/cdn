#!/bin/bash
set -e

CDN_URL="https://cdn.neelr.dev"
CONFIG_DIR="$HOME/.config/cdn"
CONFIG_FILE="$CONFIG_DIR/config"

# Config helpers
get_config() {
  [ -f "$CONFIG_FILE" ] || return 1
  grep "^$1=" "$CONFIG_FILE" 2>/dev/null | cut -d= -f2-
}

set_config() {
  mkdir -p "$CONFIG_DIR"

  # Check if key exists and get current value
  local current_value=""
  if [ -f "$CONFIG_FILE" ] && grep -q "^$1=" "$CONFIG_FILE" 2>/dev/null; then
    current_value=$(grep "^$1=" "$CONFIG_FILE" 2>/dev/null | cut -d= -f2-)

    # If value is different, prompt for confirmation
    if [ "$current_value" != "$2" ]; then
      echo -e "${YELLOW}Configuration change:${NC}"
      echo "  $1: $current_value → $2"
      echo -n "Overwrite? (y/n) [n]: "
      read -r response

      # Default to 'n' if empty, only proceed if 'y' or 'Y'
      if [ "$response" != "y" ] && [ "$response" != "Y" ]; then
        info "Cancelled - config unchanged"
        exit 0
      fi
    fi

    # Update existing key
    sed -i '' "s|^$1=.*|$1=$2|" "$CONFIG_FILE"
  else
    # Add new key (no confirmation needed for new values)
    echo "$1=$2" >> "$CONFIG_FILE"
  fi
  chmod 600 "$CONFIG_FILE"
}

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

error() { echo -e "${RED}error:${NC} $1" >&2; exit 1; }
success() { echo -e "${GREEN}$1${NC}"; }
info() { echo -e "${BLUE}$1${NC}"; }

get_token() {
  local token=$(get_config "token")
  [ -n "$token" ] || error "Not logged in. Run: cdn --login <token>"
  echo "$token"
}

json_value() {
  local key="$1"
  grep -o "\"$key\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" | head -1 | sed 's/.*:.*"\([^"]*\)".*/\1/'
}

show_help() {
  cat <<EOF
cdn - CLI for cdn.neelr.dev

USAGE:
  cdn <file> [-e EXPIRY]      Upload a file (default action)
  cdn --login <token>         Save your API token
  cdn -l, --list              List your files
  cdn -d, --delete <key>      Delete a file
  cdn -o, --open <key>        Open file URL in browser
  cdn -h, --help              Show this help

SCREENSHOT AUTO-UPLOAD (macOS):
  cdn --install-screenshot [dir]  Install daemon (default: ~/Desktop)
  cdn --uninstall-screenshot      Remove auto-upload daemon
  cdn --toggle-delete             Toggle delete screenshot after upload
  cdn --screenshot-pattern <pat>  Set glob pattern (default: Screenshot*.png)

EXPIRY OPTIONS:
  -e 30m   Expire in 30 minutes
  -e 2h    Expire in 2 hours
  -e 7d    Expire in 7 days
  -e 3600000   Raw milliseconds

EXAMPLES:
  cdn screenshot.png
  cdn video.mp4 -e 7d
  cdn --login abc123...
  cdn -l
  cdn -d x7k2m9.png
  cdn --install-screenshot
  cdn --install-screenshot ~/Screenshots
  cdn --screenshot-pattern "Screen*.png"
  cdn --screenshot-pattern "*.png"
EOF
}

do_login() {
  [ -z "$1" ] && error "Usage: cdn --login <token>"

  response=$(curl -s -X POST "$CDN_URL/api/list" \
    -H "Content-Type: application/json" \
    -d "{\"token\":\"$1\"}")

  if echo "$response" | grep -q '"files"'; then
    set_config "token" "$1"
    success "Logged in!"
  else
    error "Invalid token"
  fi
}

CHUNK_SIZE=$((50 * 1024 * 1024))  # 50MB chunks

do_upload() {
  local file="$1"
  local expiry="$2"

  [ -f "$file" ] || error "File not found: $file"

  local token=$(get_token)
  local file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
  local filename=$(basename "$file")

  # Use multipart upload for files > 50MB
  if [ "$file_size" -gt "$CHUNK_SIZE" ]; then
    do_multipart_upload "$file" "$expiry"
    return
  fi

  info "Uploading $filename..."

  local curl_args=(-s -X POST "$CDN_URL/api/upload" -F "token=$token" -F "file=@$file")
  [ -n "$expiry" ] && curl_args+=(-F "expiry=$expiry")

  response=$(curl "${curl_args[@]}")

  if echo "$response" | grep -q '"success"[[:space:]]*:[[:space:]]*true'; then
    url=$(echo "$response" | json_value "url")
    success "${CDN_URL}${url}"

    if command -v pbcopy &>/dev/null; then
      echo -n "${CDN_URL}${url}" | pbcopy
      echo "(copied)"
    elif command -v xclip &>/dev/null; then
      echo -n "${CDN_URL}${url}" | xclip -selection clipboard
      echo "(copied)"
    fi
  else
    error "Upload failed: $response"
  fi
}

do_multipart_upload() {
  local file="$1"
  local expiry="$2"
  local token=$(get_token)
  local filename=$(basename "$file")
  local file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
  local content_type=$(file -b --mime-type "$file")
  local total_chunks=$(( (file_size + CHUNK_SIZE - 1) / CHUNK_SIZE ))

  info "Large file detected ($(( file_size / 1048576 )) MB) - using multipart upload..."

  # Initialize multipart upload
  local init_response=$(curl -s -X POST "$CDN_URL/api/upload/init" \
    -H "Content-Type: application/json" \
    -d "{\"token\":\"$token\",\"filename\":\"$filename\",\"contentType\":\"$content_type\",\"size\":$file_size}")

  if ! echo "$init_response" | grep -q '"success"[[:space:]]*:[[:space:]]*true'; then
    error "Failed to initialize upload: $init_response"
  fi

  local upload_id=$(echo "$init_response" | json_value "uploadId")
  local key=$(echo "$init_response" | json_value "key")

  # Track uploaded parts
  local parts_json="["
  local first_part=true

  # Upload chunks
  for (( i=0; i<total_chunks; i++ )); do
    local part_num=$((i + 1))
    local offset=$((i * CHUNK_SIZE))
    local this_chunk_size=$CHUNK_SIZE

    # Last chunk may be smaller
    if [ $((offset + this_chunk_size)) -gt "$file_size" ]; then
      this_chunk_size=$((file_size - offset))
    fi

    echo -ne "\r\033[K${BLUE}Uploading chunk $part_num/$total_chunks...${NC}"

    # Upload chunk using dd to extract bytes and curl to upload
    # Use larger block size for better performance
    local part_response=$(dd if="$file" bs=1048576 skip=$((offset / 1048576)) count=$((this_chunk_size / 1048576 + 1)) 2>/dev/null | head -c $this_chunk_size | \
      curl -s -X POST "$CDN_URL/api/upload/part" \
        -H "X-Token: $token" \
        -H "X-Upload-Id: $upload_id" \
        -H "X-Upload-Key: $key" \
        -H "X-Part-Number: $part_num" \
        -H "Content-Type: application/octet-stream" \
        --data-binary @-)

    if ! echo "$part_response" | grep -q '"success"[[:space:]]*:[[:space:]]*true'; then
      # Abort on error
      curl -s -X POST "$CDN_URL/api/upload/abort" \
        -H "Content-Type: application/json" \
        -d "{\"token\":\"$token\",\"uploadId\":\"$upload_id\",\"key\":\"$key\"}" >/dev/null 2>&1
      echo
      error "Failed to upload chunk $part_num: $part_response"
    fi

    local etag=$(echo "$part_response" | json_value "etag")
    local part_number=$(echo "$part_response" | grep -o '"partNumber"[[:space:]]*:[[:space:]]*[0-9]*' | grep -o '[0-9]*$')

    if [ "$first_part" = true ]; then
      first_part=false
    else
      parts_json+=","
    fi
    parts_json+="{\"partNumber\":$part_number,\"etag\":\"$etag\"}"
  done
  parts_json+="]"

  echo -ne "\r\033[K${BLUE}Finalizing...${NC}"

  # Complete the upload
  local expiry_json=""
  [ -n "$expiry" ] && expiry_json=",\"expiry\":\"$expiry\""

  local complete_response=$(curl -s -X POST "$CDN_URL/api/upload/complete" \
    -H "Content-Type: application/json" \
    -d "{\"token\":\"$token\",\"uploadId\":\"$upload_id\",\"key\":\"$key\",\"parts\":$parts_json,\"filename\":\"$filename\",\"contentType\":\"$content_type\",\"size\":$file_size$expiry_json}")

  echo -ne "\r\033[K"

  if echo "$complete_response" | grep -q '"success"[[:space:]]*:[[:space:]]*true'; then
    local url=$(echo "$complete_response" | json_value "url")
    success "${CDN_URL}${url}"

    if command -v pbcopy &>/dev/null; then
      echo -n "${CDN_URL}${url}" | pbcopy
      echo "(copied)"
    elif command -v xclip &>/dev/null; then
      echo -n "${CDN_URL}${url}" | xclip -selection clipboard
      echo "(copied)"
    fi
  else
    error "Failed to complete upload: $complete_response"
  fi
}

do_list() {
  local token=$(get_token)

  response=$(curl -s -X POST "$CDN_URL/api/list" \
    -H "Content-Type: application/json" \
    -d "{\"token\":\"$token\"}")

  if ! echo "$response" | grep -q '"files"'; then
    error "Failed to list files"
  fi

  if echo "$response" | grep -q '"files"[[:space:]]*:[[:space:]]*\[\]'; then
    info "No files yet"
    return
  fi

  printf "${BLUE}%-30s  %10s  %-12s  %s${NC}\n" "NAME" "SIZE" "EXPIRES" "URL"
  printf "%-30s  %10s  %-12s  %s\n" "──────────────────────────────" "──────────" "────────────" "───────────────"

  echo "$response" | grep -o '{[^{}]*"url"[^{}]*}' | while read -r file; do
    name=$(echo "$file" | json_value "originalName")
    size=$(echo "$file" | grep -o '"size"[[:space:]]*:[[:space:]]*[0-9]*' | grep -o '[0-9]*$')
    expires=$(echo "$file" | json_value "expires")
    url=$(echo "$file" | json_value "url")

    if [ -n "$size" ]; then
      if [ "$size" -ge 1048576 ]; then
        size="$(( size / 1048576 )) MB"
      elif [ "$size" -ge 1024 ]; then
        size="$(( size / 1024 )) KB"
      else
        size="$size B"
      fi
    fi

    [ ${#name} -gt 28 ] && name="${name:0:25}..."
    [ "$expires" = "null" ] || [ -z "$expires" ] && expires="-" || expires="${expires:0:10}"

    printf "%-30s  %10s  %-12s  %s\n" "$name" "$size" "$expires" "$url"
  done
}

do_delete() {
  [ -z "$1" ] && error "Usage: cdn -d <key>"

  local token=$(get_token)

  response=$(curl -s -X POST "$CDN_URL/api/delete" \
    -H "Content-Type: application/json" \
    -d "{\"token\":\"$token\",\"key\":\"$1\"}")

  if echo "$response" | grep -q '"success"[[:space:]]*:[[:space:]]*true'; then
    success "Deleted $1"
  else
    error "Failed to delete: $response"
  fi
}

do_open() {
  [ -z "$1" ] && error "Usage: cdn -o <key>"

  local url="${CDN_URL}/$1"

  if command -v open &>/dev/null; then
    open "$url"
  elif command -v xdg-open &>/dev/null; then
    xdg-open "$url"
  else
    info "$url"
  fi
}

install_screenshot() {
  local input_dir="$1"
  local watch_dir

  # macOS only
  [[ "$OSTYPE" == "darwin"* ]] || error "Screenshot auto-upload is macOS only"

  # Check token exists
  local token=$(get_config "token")
  [ -n "$token" ] || error "Not logged in. Run: cdn --login <token>"

  # Determine watch directory: explicit arg > existing config > default
  if [ -n "$input_dir" ]; then
    watch_dir="$input_dir"
  else
    watch_dir=$(get_config "screenshot_watch_dir")
    if [ -z "$watch_dir" ]; then
      watch_dir="$HOME/Desktop"
    fi
  fi

  # Expand and validate watch directory
  watch_dir="${watch_dir/#\~/$HOME}"
  [ -d "$watch_dir" ] || error "Directory not found: $watch_dir"

  local daemon_url="https://cdn.neelr.dev/VyMOt1.sh"
  local daemon_dest="$CONFIG_DIR/screenshot-daemon.sh"
  local plist_path="$HOME/Library/LaunchAgents/com.cdn.screenshot.plist"

  # Create config dir if needed
  mkdir -p "$CONFIG_DIR"
  mkdir -p "$HOME/Library/LaunchAgents"

  # Only save to config if explicitly provided or no config exists
  if [ -n "$input_dir" ] || [ -z "$(get_config 'screenshot_watch_dir')" ]; then
    set_config "screenshot_watch_dir" "$watch_dir"
  fi

  # Download daemon script from CDN
  info "Downloading screenshot daemon..."
  curl -s "$daemon_url" -o "$daemon_dest" || error "Failed to download daemon script"
  chmod +x "$daemon_dest"

  # Generate LaunchAgent plist (uses osascript + Finder for Desktop access)
  cat > "$plist_path" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>Label</key>
  <string>com.cdn.screenshot</string>
  <key>ProgramArguments</key>
  <array>
    <string>/usr/bin/osascript</string>
    <string>-e</string>
    <string>tell application "Finder" to get files of desktop</string>
    <string>-e</string>
    <string>do shell script "$daemon_dest"</string>
  </array>
  <key>WatchPaths</key>
  <array>
    <string>$watch_dir</string>
  </array>
  <key>StandardOutPath</key>
  <string>$HOME/Library/Logs/cdn-screenshot.log</string>
  <key>StandardErrorPath</key>
  <string>$HOME/Library/Logs/cdn-screenshot.log</string>
</dict>
</plist>
EOF

  # Load the agent
  launchctl load "$plist_path"

  # Trigger Finder permission request
  info "Requesting Desktop access..."
  osascript -e 'tell application "Finder" to get files of desktop' >/dev/null 2>&1 || true

  success "Screenshot auto-upload installed!"
  info "Watching: $watch_dir"
  info "Take a screenshot (Cmd+Shift+4) and the link will be copied to your clipboard."
}

uninstall_screenshot() {
  local plist_path="$HOME/Library/LaunchAgents/com.cdn.screenshot.plist"

  # Unload if running
  launchctl unload "$plist_path" 2>/dev/null || true

  # Remove files
  rm -f "$plist_path"
  rm -f "$CONFIG_DIR/screenshot-daemon.sh"

  # Remove screenshot config keys (but keep token)
  if [ -f "$CONFIG_FILE" ]; then
    sed -i '' '/^screenshot_watch_dir=/d' "$CONFIG_FILE"
    sed -i '' '/^last_screenshot=/d' "$CONFIG_FILE"
  fi

  success "Screenshot auto-upload uninstalled"
}

toggle_delete() {
  local current=$(get_config "delete_after_upload")
  if [ "$current" = "false" ]; then
    set_config "delete_after_upload" "true"
    success "Delete after upload: ON"
  else
    set_config "delete_after_upload" "false"
    success "Delete after upload: OFF"
  fi
}

set_screenshot_pattern() {
  [ -z "$1" ] && error "Usage: cdn --screenshot-pattern <pattern>"
  set_config "screenshot_pattern" "$1"
  success "Screenshot pattern: $1"
}

# Parse arguments
[ $# -eq 0 ] && { show_help; exit 0; }

file=""
expiry=""

while [ $# -gt 0 ]; do
  case "$1" in
    -h|--help)
      show_help; exit 0 ;;
    --login)
      do_login "$2"; exit 0 ;;
    -l|--list)
      do_list; exit 0 ;;
    -d|--delete)
      do_delete "$2"; exit 0 ;;
    -o|--open)
      do_open "$2"; exit 0 ;;
    --install-screenshot)
      install_screenshot "$2"; exit 0 ;;
    --uninstall-screenshot)
      uninstall_screenshot; exit 0 ;;
    --toggle-delete)
      toggle_delete; exit 0 ;;
    --screenshot-pattern)
      set_screenshot_pattern "$2"; exit 0 ;;
    -e|--expires)
      val="$2"
      if [[ "$val" =~ ^([0-9]+)m$ ]]; then
        expiry=$(( ${BASH_REMATCH[1]} * 60000 ))
      elif [[ "$val" =~ ^([0-9]+)h$ ]]; then
        expiry=$(( ${BASH_REMATCH[1]} * 3600000 ))
      elif [[ "$val" =~ ^([0-9]+)d$ ]]; then
        expiry=$(( ${BASH_REMATCH[1]} * 86400000 ))
      elif [[ "$val" =~ ^[0-9]+$ ]]; then
        expiry="$val"
      else
        error "Invalid expiry. Use: 30m, 2h, 7d, or milliseconds"
      fi
      shift 2 ;;
    -*)
      error "Unknown option: $1" ;;
    *)
      file="$1"; shift ;;
  esac
done

# Default action: upload
[ -n "$file" ] && do_upload "$file" "$expiry"
